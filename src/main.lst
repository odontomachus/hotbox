   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Init
  12               	USART_Init:
  13               	.LFB6:
  14               		.file 1 "serial.c"
   1:serial.c      **** #include <stdlib.h>
   2:serial.c      **** 
   3:serial.c      **** 
   4:serial.c      **** #define BAUDRATE 9600UL
   5:serial.c      **** #define BAUD_PRESCALLER (((F_CPU / (BAUDRATE * 16UL))) - 1)
   6:serial.c      **** 
   7:serial.c      **** 
   8:serial.c      **** 
   9:serial.c      **** void USART_Init()
  10:serial.c      **** {
  15               		.loc 1 10 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  11:serial.c      ****     /* Set baud rate (using u2x=1 doubles effective baud rate) */
  12:serial.c      ****   UBRR0H = (uint8_t)(BAUD_PRESCALLER>>8);
  21               		.loc 1 12 0
  22 0000 1092 C500 		sts 197,__zero_reg__
  13:serial.c      ****   UBRR0L = (uint8_t)(BAUD_PRESCALLER);
  23               		.loc 1 13 0
  24 0004 85E0      		ldi r24,lo8(5)
  25 0006 8093 C400 		sts 196,r24
  14:serial.c      ****   /* Enable receiver, transmitter and rx complete interrupt */
  15:serial.c      ****   UCSR0B = (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0);
  26               		.loc 1 15 0
  27 000a 88E9      		ldi r24,lo8(-104)
  28 000c 8093 C100 		sts 193,r24
  16:serial.c      ****   /* Set frame format: 
  17:serial.c      ****    * 8 bit data (UCSZ2:0 = 0b011) 
  18:serial.c      ****    * 1 stop bit (USBS = 0) 
  19:serial.c      ****    * Async. op (UMSEL = 0) 
  20:serial.c      ****    * No parity (UPM1:0 = 0b00)*/ 
  21:serial.c      ****   UCSR0C = (3<<UCSZ00);
  29               		.loc 1 21 0
  30 0010 86E0      		ldi r24,lo8(6)
  31 0012 8093 C200 		sts 194,r24
  32 0016 0895      		ret
  33               		.cfi_endproc
  34               	.LFE6:
  36               	.global	USART_Transmit
  38               	USART_Transmit:
  39               	.LFB7:
  22:serial.c      **** }
  23:serial.c      **** 
  24:serial.c      **** /**
  25:serial.c      ****  * Send a byte.
  26:serial.c      ****  */
  27:serial.c      **** void USART_Transmit( unsigned char data )
  28:serial.c      **** {
  40               		.loc 1 28 0
  41               		.cfi_startproc
  42               	/* prologue: function */
  43               	/* frame size = 0 */
  44               	/* stack size = 0 */
  45               	.L__stack_usage = 0
  46               	.LVL0:
  47               	.L3:
  29:serial.c      ****     /* Wait for empty transmit buffer */
  30:serial.c      ****     while ( !( UCSR0A & (1<<UDRE0)) )
  48               		.loc 1 30 0 discriminator 1
  49 0018 9091 C000 		lds r25,192
  50 001c 95FF      		sbrs r25,5
  51 001e 00C0      		rjmp .L3
  31:serial.c      ****         ;
  32:serial.c      ****     /* Put data into buffer, sends the data */
  33:serial.c      ****     UDR0 = data;
  52               		.loc 1 33 0
  53 0020 8093 C600 		sts 198,r24
  54 0024 0895      		ret
  55               		.cfi_endproc
  56               	.LFE7:
  58               	.global	USART_Flush
  60               	USART_Flush:
  61               	.LFB8:
  34:serial.c      **** }
  35:serial.c      **** 
  36:serial.c      **** void USART_Flush( void )
  37:serial.c      **** {
  62               		.loc 1 37 0
  63               		.cfi_startproc
  64               	/* prologue: function */
  65               	/* frame size = 0 */
  66               	/* stack size = 0 */
  67               	.L__stack_usage = 0
  68               	.L8:
  38:serial.c      ****     unsigned char dummy;
  39:serial.c      ****     while ( UCSR0A & (1<<RXC0) ) dummy = UDR0;
  69               		.loc 1 39 0 discriminator 1
  70 0026 8091 C000 		lds r24,192
  71 002a 87FF      		sbrs r24,7
  72 002c 00C0      		rjmp .L10
  73               		.loc 1 39 0 is_stmt 0 discriminator 2
  74 002e 8091 C600 		lds r24,198
  75 0032 00C0      		rjmp .L8
  76               	.L10:
  77               	/* epilogue start */
  40:serial.c      **** }
  78               		.loc 1 40 0 is_stmt 1
  79 0034 0895      		ret
  80               		.cfi_endproc
  81               	.LFE8:
  83               	.global	USART_putstring
  85               	USART_putstring:
  86               	.LFB9:
  41:serial.c      **** 
  42:serial.c      **** void USART_putstring(char* StringPtr){
  87               		.loc 1 42 0
  88               		.cfi_startproc
  89               	.LVL1:
  90 0036 CF93      		push r28
  91               	.LCFI0:
  92               		.cfi_def_cfa_offset 3
  93               		.cfi_offset 28, -2
  94 0038 DF93      		push r29
  95               	.LCFI1:
  96               		.cfi_def_cfa_offset 4
  97               		.cfi_offset 29, -3
  98               	/* prologue: function */
  99               	/* frame size = 0 */
 100               	/* stack size = 2 */
 101               	.L__stack_usage = 2
 102 003a EC01      		movw r28,r24
 103               	.LVL2:
 104               	.L12:
  43:serial.c      ****     while(*StringPtr != 0x00){
 105               		.loc 1 43 0
 106 003c 8991      		ld r24,Y+
 107               	.LVL3:
 108 003e 8823      		tst r24
 109 0040 01F0      		breq .L14
  44:serial.c      ****         USART_Transmit(*StringPtr);
 110               		.loc 1 44 0
 111 0042 00D0      		rcall USART_Transmit
 112               	.LVL4:
 113 0044 00C0      		rjmp .L12
 114               	.LVL5:
 115               	.L14:
 116               	/* epilogue start */
  45:serial.c      ****         StringPtr++;}
  46:serial.c      ****  
  47:serial.c      **** }
 117               		.loc 1 47 0
 118 0046 DF91      		pop r29
 119 0048 CF91      		pop r28
 120               	.LVL6:
 121 004a 0895      		ret
 122               		.cfi_endproc
 123               	.LFE9:
 125               	.global	ADC_init
 127               	ADC_init:
 128               	.LFB10:
 129               		.file 2 "sensors.c"
   1:sensors.c     **** #include "sensors.h"
   2:sensors.c     **** 
   3:sensors.c     **** void ADC_init() {
 130               		.loc 2 3 0
 131               		.cfi_startproc
 132               	/* prologue: function */
 133               	/* frame size = 0 */
 134               	/* stack size = 0 */
 135               	.L__stack_usage = 0
   4:sensors.c     ****   // Set left adjusted for 8 bit precision
   5:sensors.c     ****   ADMUX |= (1<<ADLAR);
 136               		.loc 2 5 0
 137 004c ECE7      		ldi r30,lo8(124)
 138 004e F0E0      		ldi r31,0
 139 0050 8081      		ld r24,Z
 140 0052 8062      		ori r24,lo8(32)
 141 0054 8083      		st Z,r24
   6:sensors.c     ****   // Enable ADC and set prescaler to 16 ~1MHz/16 = 62kHz ~ 0.5ms for
   7:sensors.c     ****   // first measurement, 0.25ms per subsequent measurement.
   8:sensors.c     ****   ADCSRA |= (1<<ADEN) | (0b100<<ADPS0);
 142               		.loc 2 8 0
 143 0056 EAE7      		ldi r30,lo8(122)
 144 0058 F0E0      		ldi r31,0
 145 005a 8081      		ld r24,Z
 146 005c 8468      		ori r24,lo8(-124)
 147 005e 8083      		st Z,r24
   9:sensors.c     ****   // Disable digital buffer on 3 ADC pins.
  10:sensors.c     ****   DIDR0 |= (1<<ADC4D) | (1<<ADC5D) | (1<<ADC2D);
 148               		.loc 2 10 0
 149 0060 EEE7      		ldi r30,lo8(126)
 150 0062 F0E0      		ldi r31,0
 151 0064 8081      		ld r24,Z
 152 0066 8463      		ori r24,lo8(52)
 153 0068 8083      		st Z,r24
 154 006a 0895      		ret
 155               		.cfi_endproc
 156               	.LFE10:
 158               	.global	read_ts
 160               	read_ts:
 161               	.LFB11:
  11:sensors.c     **** }
  12:sensors.c     **** 
  13:sensors.c     **** /**
  14:sensors.c     ****  * Get a reading from sensors.
  15:sensors.c     ****  *
  16:sensors.c     ****  * @param mask ADMUX mask.
  17:sensors.c     ****  */
  18:sensors.c     **** unsigned int read_ts(char mux) {
 162               		.loc 2 18 0
 163               		.cfi_startproc
 164               	.LVL7:
 165               	/* prologue: function */
 166               	/* frame size = 0 */
 167               	/* stack size = 0 */
 168               	.L__stack_usage = 0
  19:sensors.c     ****   uint8_t tmp;
  20:sensors.c     **** 
  21:sensors.c     ****   // Set source to internal
  22:sensors.c     ****   ADMUX |= (0b11<<REFS0);
 169               		.loc 2 22 0
 170 006c 9091 7C00 		lds r25,124
 171 0070 906C      		ori r25,lo8(-64)
 172 0072 9093 7C00 		sts 124,r25
 173               	.LVL8:
 174               	.LBB14:
 175               	.LBB15:
 176               		.file 3 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/avr/include/util/delay.h **** #endif
  41:/usr/avr/include/util/delay.h **** 
  42:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/avr/include/util/delay.h **** #include <math.h>
  45:/usr/avr/include/util/delay.h **** 
  46:/usr/avr/include/util/delay.h **** /** \file */
  47:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/avr/include/util/delay.h ****     \code
  49:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/avr/include/util/delay.h ****     \endcode
  53:/usr/avr/include/util/delay.h **** 
  54:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/avr/include/util/delay.h ****     used.
  58:/usr/avr/include/util/delay.h **** 
  59:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/avr/include/util/delay.h **** 
  68:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/avr/include/util/delay.h **** 
  77:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/avr/include/util/delay.h **** 
  81:/usr/avr/include/util/delay.h **** */
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/avr/include/util/delay.h **** #endif
  87:/usr/avr/include/util/delay.h **** 
  88:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/avr/include/util/delay.h **** #endif
  93:/usr/avr/include/util/delay.h **** 
  94:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/avr/include/util/delay.h **** #endif
  97:/usr/avr/include/util/delay.h **** 
  98:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/avr/include/util/delay.h **** #endif
 103:/usr/avr/include/util/delay.h **** 
 104:/usr/avr/include/util/delay.h **** /**
 105:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/avr/include/util/delay.h **** 
 107:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/avr/include/util/delay.h **** 
 109:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/avr/include/util/delay.h **** 
 112:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/avr/include/util/delay.h **** 
 114:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/avr/include/util/delay.h **** 
 120:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/avr/include/util/delay.h **** 
 125:/usr/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/avr/include/util/delay.h **** 
 132:/usr/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/avr/include/util/delay.h **** 
 140:/usr/avr/include/util/delay.h ****  */
 141:/usr/avr/include/util/delay.h **** void
 142:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/avr/include/util/delay.h **** {
 144:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/avr/include/util/delay.h **** 
 153:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/avr/include/util/delay.h **** 
 156:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/avr/include/util/delay.h **** 
 159:/usr/avr/include/util/delay.h **** 	#else
 160:/usr/avr/include/util/delay.h **** 		//round up by default
 161:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/avr/include/util/delay.h **** 	#endif
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 177               		.loc 3 164 0
 178 0076 E7EA      		ldi r30,lo8(24999)
 179 0078 F1E6      		ldi r31,hi8(24999)
 180 007a 3197      		1: sbiw r30,1
 181 007c 01F4      		brne 1b
 182 007e 00C0      		rjmp .
 183 0080 0000      		nop
 184               	.LBE15:
 185               	.LBE14:
  23:sensors.c     ****   // Give cap time to discharge
  24:sensors.c     ****   _delay_ms(100);
  25:sensors.c     ****   DDRC &= ~((1<<PC5)|(1<<PC4));
 186               		.loc 2 25 0
 187 0082 97B1      		in r25,0x7
 188 0084 9F7C      		andi r25,lo8(-49)
 189 0086 97B9      		out 0x7,r25
  26:sensors.c     ****   PORTC &= ~((1<<PC5)|(1<<PC4));
 190               		.loc 2 26 0
 191 0088 98B1      		in r25,0x8
 192 008a 9F7C      		andi r25,lo8(-49)
 193 008c 98B9      		out 0x8,r25
  27:sensors.c     ****   // Set ADC4/5 as input
  28:sensors.c     ****   ADMUX = (ADMUX & ( ~(0b1111<<MUX0) )) | (mux<<MUX0);
 194               		.loc 2 28 0
 195 008e 9091 7C00 		lds r25,124
 196 0092 907F      		andi r25,lo8(-16)
 197 0094 892B      		or r24,r25
 198               	.LVL9:
 199 0096 8093 7C00 		sts 124,r24
 200               	.LVL10:
 201               	.LBB16:
 202               	.LBB17:
 203               		.loc 3 164 0
 204 009a 89EF      		ldi r24,lo8(249)
 205 009c 90E0      		ldi r25,hi8(249)
 206 009e 0197      		1: sbiw r24,1
 207 00a0 01F4      		brne 1b
 208 00a2 00C0      		rjmp .
 209 00a4 0000      		nop
 210               	.LBE17:
 211               	.LBE16:
  29:sensors.c     ****   _delay_ms(1);
  30:sensors.c     ****   // Start conversion
  31:sensors.c     ****   ADCSRA |= 1 << ADSC;
 212               		.loc 2 31 0
 213 00a6 8091 7A00 		lds r24,122
 214 00aa 8064      		ori r24,lo8(64)
 215 00ac 8093 7A00 		sts 122,r24
 216               	.L17:
  32:sensors.c     ****   // Wait for conversion to finish
  33:sensors.c     ****   while (ADCSRA & (1<<ADSC)) {
 217               		.loc 2 33 0
 218 00b0 8091 7A00 		lds r24,122
 219 00b4 86FF      		sbrs r24,6
 220 00b6 00C0      		rjmp .L21
 221               	.LVL11:
 222               	.LBB18:
 223               	.LBB19:
 165:/usr/avr/include/util/delay.h **** 
 166:/usr/avr/include/util/delay.h **** #else
 167:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/avr/include/util/delay.h **** 	{
 172:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/avr/include/util/delay.h **** 		{
 176:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/avr/include/util/delay.h **** 		}
 180:/usr/avr/include/util/delay.h **** 		return;
 181:/usr/avr/include/util/delay.h **** 	}
 182:/usr/avr/include/util/delay.h **** 	else
 183:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/avr/include/util/delay.h **** #endif
 186:/usr/avr/include/util/delay.h **** }
 187:/usr/avr/include/util/delay.h **** 
 188:/usr/avr/include/util/delay.h **** /**
 189:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/avr/include/util/delay.h **** 
 191:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/avr/include/util/delay.h **** 
 193:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/avr/include/util/delay.h **** 
 196:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/avr/include/util/delay.h **** 
 198:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/avr/include/util/delay.h **** 
 202:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/avr/include/util/delay.h ****   
 207:/usr/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/avr/include/util/delay.h **** 
 211:/usr/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/avr/include/util/delay.h ****  
 214:/usr/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****  */
 223:/usr/avr/include/util/delay.h **** void
 224:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/avr/include/util/delay.h **** {
 226:/usr/avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/avr/include/util/delay.h **** 
 235:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/avr/include/util/delay.h **** 
 238:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h **** 	#else
 242:/usr/avr/include/util/delay.h **** 		//round up by default
 243:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/avr/include/util/delay.h **** 	#endif
 245:/usr/avr/include/util/delay.h **** 
 246:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 224               		.loc 3 246 0
 225 00b8 90E1      		ldi r25,lo8(16)
 226 00ba 9A95      		1: dec r25
 227 00bc 01F4      		brne 1b
 228 00be 00C0      		rjmp .
 229 00c0 00C0      		rjmp .L17
 230               	.LVL12:
 231               	.L21:
 232               	.LBE19:
 233               	.LBE18:
  34:sensors.c     ****     _delay_us(50);
  35:sensors.c     ****   }
  36:sensors.c     ****   tmp = ADCH;// Discard first measurement after channel switch
 234               		.loc 2 36 0
 235 00c2 8091 7900 		lds r24,121
  37:sensors.c     **** 
  38:sensors.c     ****   // Start conversion
  39:sensors.c     ****   ADCSRA |= 1 << ADSC;
 236               		.loc 2 39 0
 237 00c6 8091 7A00 		lds r24,122
 238 00ca 8064      		ori r24,lo8(64)
 239 00cc 8093 7A00 		sts 122,r24
 240               	.L19:
  40:sensors.c     ****   // Wait for conversion to finish
  41:sensors.c     ****   while (ADCSRA & (1<<ADSC)) {
 241               		.loc 2 41 0
 242 00d0 8091 7A00 		lds r24,122
 243 00d4 86FF      		sbrs r24,6
 244 00d6 00C0      		rjmp .L22
 245               	.LVL13:
 246               	.LBB20:
 247               	.LBB21:
 248               		.loc 3 246 0
 249 00d8 E0E1      		ldi r30,lo8(16)
 250 00da EA95      		1: dec r30
 251 00dc 01F4      		brne 1b
 252 00de 00C0      		rjmp .
 253 00e0 00C0      		rjmp .L19
 254               	.LVL14:
 255               	.L22:
 256               	.LBE21:
 257               	.LBE20:
  42:sensors.c     ****     _delay_us(50);
  43:sensors.c     ****   }
  44:sensors.c     **** 
  45:sensors.c     ****   return ((ADCL>>6) | (ADCH<<2));
 258               		.loc 2 45 0
 259 00e2 2091 7800 		lds r18,120
 260 00e6 8091 7900 		lds r24,121
 261 00ea F4E0      		ldi r31,lo8(4)
 262 00ec 8F9F      		mul r24,r31
 263 00ee C001      		movw r24,r0
 264 00f0 1124      		clr __zero_reg__
 265 00f2 2295      		swap r18
 266 00f4 2695      		lsr r18
 267 00f6 2695      		lsr r18
 268 00f8 2370      		andi r18,lo8(3)
  46:sensors.c     **** }
 269               		.loc 2 46 0
 270 00fa 822B      		or r24,r18
 271 00fc 0895      		ret
 272               		.cfi_endproc
 273               	.LFE11:
 275               	.global	__floatunsisf
 276               	.global	__addsf3
 277               	.global	__subsf3
 278               	.global	__mulsf3
 279               	.global	__divsf3
 280               	.global	__fixsfsi
 281               	.global	phys_temp
 283               	phys_temp:
 284               	.LFB12:
  47:sensors.c     **** 
  48:sensors.c     **** /**
  49:sensors.c     ****  * Get temperature readings.
  50:sensors.c     ****  */
  51:sensors.c     **** unsigned int phys_temp(int i) {
 285               		.loc 2 51 0
 286               		.cfi_startproc
 287               	.LVL15:
 288 00fe 8F92      		push r8
 289               	.LCFI2:
 290               		.cfi_def_cfa_offset 3
 291               		.cfi_offset 8, -2
 292 0100 9F92      		push r9
 293               	.LCFI3:
 294               		.cfi_def_cfa_offset 4
 295               		.cfi_offset 9, -3
 296 0102 AF92      		push r10
 297               	.LCFI4:
 298               		.cfi_def_cfa_offset 5
 299               		.cfi_offset 10, -4
 300 0104 BF92      		push r11
 301               	.LCFI5:
 302               		.cfi_def_cfa_offset 6
 303               		.cfi_offset 11, -5
 304 0106 CF92      		push r12
 305               	.LCFI6:
 306               		.cfi_def_cfa_offset 7
 307               		.cfi_offset 12, -6
 308 0108 DF92      		push r13
 309               	.LCFI7:
 310               		.cfi_def_cfa_offset 8
 311               		.cfi_offset 13, -7
 312 010a EF92      		push r14
 313               	.LCFI8:
 314               		.cfi_def_cfa_offset 9
 315               		.cfi_offset 14, -8
 316 010c FF92      		push r15
 317               	.LCFI9:
 318               		.cfi_def_cfa_offset 10
 319               		.cfi_offset 15, -9
 320 010e 0F93      		push r16
 321               	.LCFI10:
 322               		.cfi_def_cfa_offset 11
 323               		.cfi_offset 16, -10
 324 0110 1F93      		push r17
 325               	.LCFI11:
 326               		.cfi_def_cfa_offset 12
 327               		.cfi_offset 17, -11
 328 0112 CF93      		push r28
 329               	.LCFI12:
 330               		.cfi_def_cfa_offset 13
 331               		.cfi_offset 28, -12
 332 0114 DF93      		push r29
 333               	.LCFI13:
 334               		.cfi_def_cfa_offset 14
 335               		.cfi_offset 29, -13
 336 0116 00D0      		rcall .
 337 0118 00D0      		rcall .
 338               	.LCFI14:
 339               		.cfi_def_cfa_offset 18
 340 011a CDB7      		in r28,__SP_L__
 341 011c DEB7      		in r29,__SP_H__
 342               	.LCFI15:
 343               		.cfi_def_cfa_register 28
 344               	/* prologue: function */
 345               	/* frame size = 4 */
 346               	/* stack size = 16 */
 347               	.L__stack_usage = 16
 348 011e 8C01      		movw r16,r24
  52:sensors.c     ****   double d_temp, sensor, log_res;
  53:sensors.c     ****   // Add 0.1 to make sure it's not 0.
  54:sensors.c     ****   sensor = (double) read_ts(mux_mask[i])+0.1;
 349               		.loc 2 54 0
 350 0120 FC01      		movw r30,r24
 351 0122 E050      		subi r30,lo8(-(mux_mask))
 352 0124 F040      		sbci r31,hi8(-(mux_mask))
 353 0126 8081      		ld r24,Z
 354               	.LVL16:
 355 0128 00D0      		rcall read_ts
 356               	.LVL17:
 357 012a BC01      		movw r22,r24
 358 012c 80E0      		ldi r24,0
 359 012e 90E0      		ldi r25,0
 360 0130 00D0      		rcall __floatunsisf
 361               	.LVL18:
 362 0132 2DEC      		ldi r18,lo8(-51)
 363 0134 3CEC      		ldi r19,lo8(-52)
 364 0136 4CEC      		ldi r20,lo8(-52)
 365 0138 5DE3      		ldi r21,lo8(61)
 366 013a 00D0      		rcall __addsf3
 367               	.LVL19:
 368 013c 9B01      		movw r18,r22
 369 013e AC01      		movw r20,r24
 370               	.LVL20:
  55:sensors.c     **** 
  56:sensors.c     ****   // Get log of resistance from V measurement.
  57:sensors.c     ****   log_res = log(sensor) + log_resistors[i] - log(1024-sensor);
 371               		.loc 2 57 0
 372 0140 2983      		std Y+1,r18
 373 0142 3A83      		std Y+2,r19
 374 0144 4B83      		std Y+3,r20
 375 0146 5C83      		std Y+4,r21
 376 0148 00D0      		rcall log
 377               	.LVL21:
 378 014a 6B01      		movw r12,r22
 379 014c 7C01      		movw r14,r24
 380 014e 2981      		ldd r18,Y+1
 381 0150 3A81      		ldd r19,Y+2
 382 0152 4B81      		ldd r20,Y+3
 383 0154 5C81      		ldd r21,Y+4
 384 0156 60E0      		ldi r22,0
 385 0158 70E0      		ldi r23,0
 386 015a 80E8      		ldi r24,lo8(-128)
 387 015c 94E4      		ldi r25,lo8(68)
 388 015e 00D0      		rcall __subsf3
 389               	.LVL22:
 390 0160 00D0      		rcall log
 391               	.LVL23:
 392 0162 4B01      		movw r8,r22
 393 0164 5C01      		movw r10,r24
 394 0166 F801      		movw r30,r16
 395 0168 EE0F      		lsl r30
 396 016a FF1F      		rol r31
 397 016c EE0F      		lsl r30
 398 016e FF1F      		rol r31
 399 0170 E050      		subi r30,lo8(-(log_resistors))
 400 0172 F040      		sbci r31,hi8(-(log_resistors))
 401 0174 2081      		ld r18,Z
 402 0176 3181      		ldd r19,Z+1
 403 0178 4281      		ldd r20,Z+2
 404 017a 5381      		ldd r21,Z+3
 405 017c C701      		movw r24,r14
 406 017e B601      		movw r22,r12
 407 0180 00D0      		rcall __addsf3
 408               	.LVL24:
 409 0182 A501      		movw r20,r10
 410 0184 9401      		movw r18,r8
 411 0186 00D0      		rcall __subsf3
 412               	.LVL25:
 413 0188 6B01      		movw r12,r22
 414 018a 7C01      		movw r14,r24
 415               	.LVL26:
  58:sensors.c     ****   d_temp = 1.0/(phys_params[i][0]+phys_params[i][1]*log_res + phys_params[i][2]*pow(log_res,3)) - 2
 416               		.loc 2 58 0
 417 018c 20E0      		ldi r18,0
 418 018e 30E0      		ldi r19,0
 419 0190 40E4      		ldi r20,lo8(64)
 420 0192 50E4      		ldi r21,lo8(64)
 421 0194 00D0      		rcall pow
 422               	.LVL27:
 423 0196 4B01      		movw r8,r22
 424 0198 5C01      		movw r10,r24
 425               	.LVL28:
 426 019a 8CE0      		ldi r24,lo8(12)
 427 019c 809F      		mul r24,r16
 428 019e 9001      		movw r18,r0
 429 01a0 819F      		mul r24,r17
 430 01a2 300D      		add r19,r0
 431 01a4 1124      		clr __zero_reg__
 432 01a6 8901      		movw r16,r18
 433               	.LVL29:
 434 01a8 0050      		subi r16,lo8(-(phys_params))
 435 01aa 1040      		sbci r17,hi8(-(phys_params))
 436 01ac F801      		movw r30,r16
 437 01ae 2481      		ldd r18,Z+4
 438 01b0 3581      		ldd r19,Z+5
 439 01b2 4681      		ldd r20,Z+6
 440 01b4 5781      		ldd r21,Z+7
 441 01b6 C701      		movw r24,r14
 442 01b8 B601      		movw r22,r12
 443 01ba 00D0      		rcall __mulsf3
 444               	.LVL30:
 445 01bc F801      		movw r30,r16
 446 01be 2081      		ld r18,Z
 447 01c0 3181      		ldd r19,Z+1
 448 01c2 4281      		ldd r20,Z+2
 449 01c4 5381      		ldd r21,Z+3
 450 01c6 00D0      		rcall __addsf3
 451               	.LVL31:
 452 01c8 6B01      		movw r12,r22
 453 01ca 7C01      		movw r14,r24
 454               	.LVL32:
 455 01cc F801      		movw r30,r16
 456 01ce 2085      		ldd r18,Z+8
 457 01d0 3185      		ldd r19,Z+9
 458 01d2 4285      		ldd r20,Z+10
 459 01d4 5385      		ldd r21,Z+11
 460 01d6 C501      		movw r24,r10
 461 01d8 B401      		movw r22,r8
 462 01da 00D0      		rcall __mulsf3
 463               	.LVL33:
 464 01dc 9B01      		movw r18,r22
 465 01de AC01      		movw r20,r24
 466 01e0 C701      		movw r24,r14
 467 01e2 B601      		movw r22,r12
 468 01e4 00D0      		rcall __addsf3
 469               	.LVL34:
 470 01e6 9B01      		movw r18,r22
 471 01e8 AC01      		movw r20,r24
 472 01ea 60E0      		ldi r22,0
 473 01ec 70E0      		ldi r23,0
 474 01ee 80E8      		ldi r24,lo8(-128)
 475 01f0 9FE3      		ldi r25,lo8(63)
 476 01f2 00D0      		rcall __divsf3
 477               	.LVL35:
 478 01f4 23E3      		ldi r18,lo8(51)
 479 01f6 33E9      		ldi r19,lo8(-109)
 480 01f8 48E8      		ldi r20,lo8(-120)
 481 01fa 53E4      		ldi r21,lo8(67)
 482 01fc 00D0      		rcall __subsf3
 483               	.LVL36:
  59:sensors.c     **** 
  60:sensors.c     ****   return (int) d_temp;
 484               		.loc 2 60 0
 485 01fe 00D0      		rcall __fixsfsi
 486               	.LVL37:
  61:sensors.c     **** }
 487               		.loc 2 61 0
 488 0200 CB01      		movw r24,r22
 489               	/* epilogue start */
 490 0202 0F90      		pop __tmp_reg__
 491 0204 0F90      		pop __tmp_reg__
 492 0206 0F90      		pop __tmp_reg__
 493 0208 0F90      		pop __tmp_reg__
 494 020a DF91      		pop r29
 495 020c CF91      		pop r28
 496 020e 1F91      		pop r17
 497 0210 0F91      		pop r16
 498 0212 FF90      		pop r15
 499 0214 EF90      		pop r14
 500 0216 DF90      		pop r13
 501 0218 CF90      		pop r12
 502 021a BF90      		pop r11
 503 021c AF90      		pop r10
 504 021e 9F90      		pop r9
 505 0220 8F90      		pop r8
 506 0222 0895      		ret
 507               		.cfi_endproc
 508               	.LFE12:
 510               	.global	RTC_init
 512               	RTC_init:
 513               	.LFB13:
 514               		.file 4 "rtc.c"
   1:rtc.c         **** /** 
   2:rtc.c         ****  * Start Timer/Counter2 in asynchronous operation using a 32.768kHz crystal for RTC.
   3:rtc.c         ****  */
   4:rtc.c         **** void RTC_init(void)
   5:rtc.c         **** {
 515               		.loc 4 5 0
 516               		.cfi_startproc
 517               	/* prologue: function */
 518               	/* frame size = 0 */
 519               	/* stack size = 0 */
 520               	.L__stack_usage = 0
 521               	.LVL38:
 522               	.LBB22:
 523               	.LBB23:
 164:/usr/avr/include/util/delay.h **** 
 524               		.loc 3 164 0
 525 0224 2FE3      		ldi r18,lo8(199999)
 526 0226 8DE0      		ldi r24,hi8(199999)
 527 0228 93E0      		ldi r25,hlo8(199999)
 528 022a 2150      		1: subi r18,1
 529 022c 8040      		sbci r24,0
 530 022e 9040      		sbci r25,0
 531 0230 01F4      		brne 1b
 532 0232 00C0      		rjmp .
 533 0234 0000      		nop
 534               	.LBE23:
 535               	.LBE22:
   6:rtc.c         ****   // Oscillator might take as long as one second to stabilize.
   7:rtc.c         ****   _delay_ms(1000);
   8:rtc.c         ****   // Disable the Timer/Counter2 interrupts
   9:rtc.c         ****   TIMSK2 &= ~((1<<OCIE2A)|(1<<OCIE2B)|(1<<TOIE2));
 536               		.loc 4 9 0
 537 0236 8091 7000 		lds r24,112
 538 023a 887F      		andi r24,lo8(-8)
 539 023c 8093 7000 		sts 112,r24
  10:rtc.c         ****   // Select clock source by setting AS2 as appropriate.
  11:rtc.c         ****   ASSR = (1<<AS2);
 540               		.loc 4 11 0
 541 0240 80E2      		ldi r24,lo8(32)
 542 0242 8093 B600 		sts 182,r24
  12:rtc.c         ****   // Set prescaler to 128: 32.768 kHz / 128 = 1 sec between each overflow
  13:rtc.c         ****   TCCR2B |= (1<<CS22) | (1<<CS20);            
 543               		.loc 4 13 0
 544 0246 8091 B100 		lds r24,177
 545 024a 8560      		ori r24,lo8(5)
 546 024c 8093 B100 		sts 177,r24
  14:rtc.c         ****   // Reset TCNT2
  15:rtc.c         ****   TCNT2 = 0;
 547               		.loc 4 15 0
 548 0250 1092 B200 		sts 178,__zero_reg__
 549               	.L25:
  16:rtc.c         **** 	
  17:rtc.c         ****   // Wait for clock edge
  18:rtc.c         ****   while(ASSR & 0x1F);
 550               		.loc 4 18 0 discriminator 1
 551 0254 8091 B600 		lds r24,182
 552 0258 8F71      		andi r24,lo8(31)
 553 025a 01F4      		brne .L25
  19:rtc.c         **** 
  20:rtc.c         ****   // Clear timer interrupt flag registers
  21:rtc.c         ****   TIFR2 |= ((1<<OCF2A)|(1<<OCF2B)|(1<<TOV2));
 554               		.loc 4 21 0
 555 025c 87B3      		in r24,0x17
 556 025e 8760      		ori r24,lo8(7)
 557 0260 87BB      		out 0x17,r24
  22:rtc.c         ****   // Enable timer overflow interrupt
  23:rtc.c         ****   TIMSK2 |= (1<<TOIE2);
 558               		.loc 4 23 0
 559 0262 8091 7000 		lds r24,112
 560 0266 8160      		ori r24,lo8(1)
 561 0268 8093 7000 		sts 112,r24
 562 026c 0895      		ret
 563               		.cfi_endproc
 564               	.LFE13:
 566               		.section	.rodata.str1.1,"aMS",@progbits,1
 567               	.LC0:
 568 0000 4F4B 00   		.string	"OK"
 569               		.text
 570               	.global	__vector_18
 572               	__vector_18:
 573               	.LFB14:
 574               		.file 5 "main.c"
   1:main.c        **** #include <stdlib.h>
   2:main.c        **** #include <avr/interrupt.h>
   3:main.c        **** #include <util/delay.h>
   4:main.c        **** #include <avr/io.h>
   5:main.c        **** 
   6:main.c        **** #include "serial.c"
   7:main.c        **** #include "sensors.c"
   8:main.c        **** #include "rtc.c"
   9:main.c        **** #include "math.h"
  10:main.c        **** 
  11:main.c        **** #define MAX(a,b) (a>b ? a : b)
  12:main.c        **** 
  13:main.c        **** volatile unsigned char update;
  14:main.c        **** volatile unsigned char start;
  15:main.c        **** volatile unsigned char status;
  16:main.c        **** 
  17:main.c        **** /*
  18:main.c        ****  * ISR RX complete
  19:main.c        ****  * Receive a byte from serial and act on it.
  20:main.c        ****  */
  21:main.c        **** ISR(USART_RX_vect) {
 575               		.loc 5 21 0
 576               		.cfi_startproc
 577 026e 1F92      		push r1
 578               	.LCFI16:
 579               		.cfi_def_cfa_offset 3
 580               		.cfi_offset 1, -2
 581 0270 0F92      		push r0
 582               	.LCFI17:
 583               		.cfi_def_cfa_offset 4
 584               		.cfi_offset 0, -3
 585 0272 0FB6      		in r0,__SREG__
 586 0274 0F92      		push r0
 587 0276 1124      		clr __zero_reg__
 588 0278 2F93      		push r18
 589               	.LCFI18:
 590               		.cfi_def_cfa_offset 5
 591               		.cfi_offset 18, -4
 592 027a 3F93      		push r19
 593               	.LCFI19:
 594               		.cfi_def_cfa_offset 6
 595               		.cfi_offset 19, -5
 596 027c 4F93      		push r20
 597               	.LCFI20:
 598               		.cfi_def_cfa_offset 7
 599               		.cfi_offset 20, -6
 600 027e 5F93      		push r21
 601               	.LCFI21:
 602               		.cfi_def_cfa_offset 8
 603               		.cfi_offset 21, -7
 604 0280 6F93      		push r22
 605               	.LCFI22:
 606               		.cfi_def_cfa_offset 9
 607               		.cfi_offset 22, -8
 608 0282 7F93      		push r23
 609               	.LCFI23:
 610               		.cfi_def_cfa_offset 10
 611               		.cfi_offset 23, -9
 612 0284 8F93      		push r24
 613               	.LCFI24:
 614               		.cfi_def_cfa_offset 11
 615               		.cfi_offset 24, -10
 616 0286 9F93      		push r25
 617               	.LCFI25:
 618               		.cfi_def_cfa_offset 12
 619               		.cfi_offset 25, -11
 620 0288 AF93      		push r26
 621               	.LCFI26:
 622               		.cfi_def_cfa_offset 13
 623               		.cfi_offset 26, -12
 624 028a BF93      		push r27
 625               	.LCFI27:
 626               		.cfi_def_cfa_offset 14
 627               		.cfi_offset 27, -13
 628 028c CF93      		push r28
 629               	.LCFI28:
 630               		.cfi_def_cfa_offset 15
 631               		.cfi_offset 28, -14
 632 028e EF93      		push r30
 633               	.LCFI29:
 634               		.cfi_def_cfa_offset 16
 635               		.cfi_offset 30, -15
 636 0290 FF93      		push r31
 637               	.LCFI30:
 638               		.cfi_def_cfa_offset 17
 639               		.cfi_offset 31, -16
 640               	/* prologue: Signal */
 641               	/* frame size = 0 */
 642               	/* stack size = 16 */
 643               	.L__stack_usage = 16
  22:main.c        ****   uint8_t r = UDR0;
 644               		.loc 5 22 0
 645 0292 C091 C600 		lds r28,198
 646               	.LVL39:
  23:main.c        ****   USART_putstring("OK");
 647               		.loc 5 23 0
 648 0296 80E0      		ldi r24,lo8(.LC0)
 649 0298 90E0      		ldi r25,hi8(.LC0)
 650 029a 00D0      		rcall USART_putstring
 651               	.LVL40:
  24:main.c        ****   switch (r) {
 652               		.loc 5 24 0
 653 029c C337      		cpi r28,lo8(115)
 654 029e 01F0      		breq .L29
 655 02a0 C437      		cpi r28,lo8(116)
 656 02a2 01F4      		brne .L27
  25:main.c        ****   case 's':
  26:main.c        ****     start = 1;
  27:main.c        ****     break;
  28:main.c        ****   case 't':
  29:main.c        ****     start = 0;
 657               		.loc 5 29 0
 658 02a4 1092 0000 		sts start,__zero_reg__
  30:main.c        ****     break;
 659               		.loc 5 30 0
 660 02a8 00C0      		rjmp .L27
 661               	.L29:
  26:main.c        ****     break;
 662               		.loc 5 26 0
 663 02aa 81E0      		ldi r24,lo8(1)
 664 02ac 8093 0000 		sts start,r24
 665               	.L27:
 666               	/* epilogue start */
  31:main.c        ****   }
  32:main.c        **** }
 667               		.loc 5 32 0
 668 02b0 FF91      		pop r31
 669 02b2 EF91      		pop r30
 670 02b4 CF91      		pop r28
 671               	.LVL41:
 672 02b6 BF91      		pop r27
 673 02b8 AF91      		pop r26
 674 02ba 9F91      		pop r25
 675 02bc 8F91      		pop r24
 676 02be 7F91      		pop r23
 677 02c0 6F91      		pop r22
 678 02c2 5F91      		pop r21
 679 02c4 4F91      		pop r20
 680 02c6 3F91      		pop r19
 681 02c8 2F91      		pop r18
 682 02ca 0F90      		pop r0
 683 02cc 0FBE      		out __SREG__,r0
 684 02ce 0F90      		pop r0
 685 02d0 1F90      		pop r1
 686 02d2 1895      		reti
 687               		.cfi_endproc
 688               	.LFE14:
 690               		.section	.rodata.str1.1
 691               	.LC1:
 692 0003 4D53 473A 		.string	"MSG:12:"
 692      3132 3A00 
 693               	.LC2:
 694 000b 3A45 4F4D 		.string	":EOM:"
 694      3A00 
 695               	.global	__floatsisf
 696               	.global	__gtsf2
 697               	.global	__fixunssfsi
 698               	.global	__ltsf2
 699               		.text
 700               	.global	run
 702               	run:
 703               	.LFB15:
  33:main.c        **** 
  34:main.c        **** void run() {
 704               		.loc 5 34 0
 705               		.cfi_startproc
 706 02d4 4F92      		push r4
 707               	.LCFI31:
 708               		.cfi_def_cfa_offset 3
 709               		.cfi_offset 4, -2
 710 02d6 5F92      		push r5
 711               	.LCFI32:
 712               		.cfi_def_cfa_offset 4
 713               		.cfi_offset 5, -3
 714 02d8 6F92      		push r6
 715               	.LCFI33:
 716               		.cfi_def_cfa_offset 5
 717               		.cfi_offset 6, -4
 718 02da 7F92      		push r7
 719               	.LCFI34:
 720               		.cfi_def_cfa_offset 6
 721               		.cfi_offset 7, -5
 722 02dc 8F92      		push r8
 723               	.LCFI35:
 724               		.cfi_def_cfa_offset 7
 725               		.cfi_offset 8, -6
 726 02de 9F92      		push r9
 727               	.LCFI36:
 728               		.cfi_def_cfa_offset 8
 729               		.cfi_offset 9, -7
 730 02e0 AF92      		push r10
 731               	.LCFI37:
 732               		.cfi_def_cfa_offset 9
 733               		.cfi_offset 10, -8
 734 02e2 BF92      		push r11
 735               	.LCFI38:
 736               		.cfi_def_cfa_offset 10
 737               		.cfi_offset 11, -9
 738 02e4 CF92      		push r12
 739               	.LCFI39:
 740               		.cfi_def_cfa_offset 11
 741               		.cfi_offset 12, -10
 742 02e6 DF92      		push r13
 743               	.LCFI40:
 744               		.cfi_def_cfa_offset 12
 745               		.cfi_offset 13, -11
 746 02e8 EF92      		push r14
 747               	.LCFI41:
 748               		.cfi_def_cfa_offset 13
 749               		.cfi_offset 14, -12
 750 02ea FF92      		push r15
 751               	.LCFI42:
 752               		.cfi_def_cfa_offset 14
 753               		.cfi_offset 15, -13
 754 02ec 0F93      		push r16
 755               	.LCFI43:
 756               		.cfi_def_cfa_offset 15
 757               		.cfi_offset 16, -14
 758 02ee 1F93      		push r17
 759               	.LCFI44:
 760               		.cfi_def_cfa_offset 16
 761               		.cfi_offset 17, -15
 762 02f0 CF93      		push r28
 763               	.LCFI45:
 764               		.cfi_def_cfa_offset 17
 765               		.cfi_offset 28, -16
 766 02f2 DF93      		push r29
 767               	.LCFI46:
 768               		.cfi_def_cfa_offset 18
 769               		.cfi_offset 29, -17
 770               	/* prologue: function */
 771               	/* frame size = 0 */
 772               	/* stack size = 16 */
 773               	.L__stack_usage = 16
 774               	.LVL42:
  35:main.c        ****   unsigned int set_time, set_temp, countdown;
  36:main.c        **** 
  37:main.c        ****   unsigned char cycle, part;
  38:main.c        ****   unsigned char temp1, temp2, last_temp;
  39:main.c        ****   float dt, dg;
  40:main.c        **** 
  41:main.c        ****   set_temp = 53;
  42:main.c        ****   set_time = 3600*6;
  43:main.c        ****   countdown = set_time;
  44:main.c        **** 
  45:main.c        ****   part = cycle = 0;
 775               		.loc 5 45 0
 776 02f4 D0E0      		ldi r29,0
 777 02f6 C0E0      		ldi r28,0
  43:main.c        **** 
 778               		.loc 5 43 0
 779 02f8 80E6      		ldi r24,lo8(96)
 780 02fa C82E      		mov r12,r24
 781 02fc 84E5      		ldi r24,lo8(84)
 782 02fe D82E      		mov r13,r24
  46:main.c        ****   while (countdown-- > 0) {
  47:main.c        ****     temp1 = phys_temp(0);
  48:main.c        ****     temp2 = phys_temp(1);
  49:main.c        **** 
  50:main.c        ****     USART_putstring("MSG:12:");
  51:main.c        ****     USART_Transmit('T');
  52:main.c        ****     USART_Transmit(temp1);
  53:main.c        ****     USART_Transmit(temp2);
  54:main.c        ****     USART_Transmit('C');
  55:main.c        ****     USART_Transmit(countdown>>8);
  56:main.c        ****     USART_Transmit(countdown);
  57:main.c        ****     USART_Transmit('P');
  58:main.c        ****     USART_Transmit(part);
  59:main.c        ****     USART_Transmit('Y');
  60:main.c        ****     USART_Transmit(cycle);
  61:main.c        ****     USART_Transmit('S');
  62:main.c        ****     USART_Transmit(PORTD & (1<<PD5));
  63:main.c        ****     USART_putstring(":EOM:");
  64:main.c        **** 
  65:main.c        ****     if ((cycle%30)==0) {
 783               		.loc 5 65 0
 784 0300 0EE1      		ldi r16,lo8(30)
  66:main.c        ****       temp1 = MAX(temp1, temp2);
  67:main.c        ****       dt = temp1 - last_temp;
  68:main.c        ****       dg = last_temp - temp1;
  69:main.c        ****       last_temp = temp1;
  70:main.c        ****       if ((dg - dt) > 0) {
  71:main.c        ****         part = part + round((30.0-part)/2.0);
  72:main.c        ****       }
  73:main.c        ****       else if ((dg - dt) < 0) {
  74:main.c        ****         if (part > 0) {
  75:main.c        ****           part = part / 2;
  76:main.c        ****         }
  77:main.c        ****       }
  78:main.c        ****     }
  79:main.c        **** 
  80:main.c        ****     if (cycle == part) {
  81:main.c        ****       PORTD &= ~(1<<PD5);
  82:main.c        ****     }
  83:main.c        ****     if (cycle == 0) {
  84:main.c        ****       if (part > 0) {
  85:main.c        ****         PORTD |= (1<<PD5);
  86:main.c        ****       }
  87:main.c        ****     }
  88:main.c        ****     cycle = (cycle + 1)%30;
 785               		.loc 5 88 0
 786 0302 9EE1      		ldi r25,lo8(30)
 787 0304 892E      		mov r8,r25
 788 0306 912C      		mov r9,__zero_reg__
 789               	.LVL43:
 790               	.L32:
  46:main.c        ****   while (countdown-- > 0) {
 791               		.loc 5 46 0
 792               	.LVL44:
 793 0308 21E0      		ldi r18,1
 794 030a C21A      		sub r12,r18
 795 030c D108      		sbc r13,__zero_reg__
 796 030e 00F4      		brcc .+2
 797 0310 00C0      		rjmp .L51
  47:main.c        ****     temp2 = phys_temp(1);
 798               		.loc 5 47 0
 799 0312 80E0      		ldi r24,0
 800 0314 90E0      		ldi r25,0
 801 0316 00D0      		rcall phys_temp
 802               	.LVL45:
 803 0318 F82E      		mov r15,r24
 804               	.LVL46:
  48:main.c        **** 
 805               		.loc 5 48 0
 806 031a 81E0      		ldi r24,lo8(1)
 807 031c 90E0      		ldi r25,0
 808 031e 00D0      		rcall phys_temp
 809               	.LVL47:
 810 0320 182F      		mov r17,r24
 811               	.LVL48:
  50:main.c        ****     USART_Transmit('T');
 812               		.loc 5 50 0
 813 0322 80E0      		ldi r24,lo8(.LC1)
 814 0324 90E0      		ldi r25,hi8(.LC1)
 815 0326 00D0      		rcall USART_putstring
 816               	.LVL49:
  51:main.c        ****     USART_Transmit(temp1);
 817               		.loc 5 51 0
 818 0328 84E5      		ldi r24,lo8(84)
 819 032a 00D0      		rcall USART_Transmit
 820               	.LVL50:
  52:main.c        ****     USART_Transmit(temp2);
 821               		.loc 5 52 0
 822 032c 8F2D      		mov r24,r15
 823 032e 00D0      		rcall USART_Transmit
 824               	.LVL51:
  53:main.c        ****     USART_Transmit('C');
 825               		.loc 5 53 0
 826 0330 812F      		mov r24,r17
 827 0332 00D0      		rcall USART_Transmit
 828               	.LVL52:
  54:main.c        ****     USART_Transmit(countdown>>8);
 829               		.loc 5 54 0
 830 0334 83E4      		ldi r24,lo8(67)
 831 0336 00D0      		rcall USART_Transmit
 832               	.LVL53:
  55:main.c        ****     USART_Transmit(countdown);
 833               		.loc 5 55 0
 834 0338 8D2D      		mov r24,r13
 835 033a 00D0      		rcall USART_Transmit
 836               	.LVL54:
  56:main.c        ****     USART_Transmit('P');
 837               		.loc 5 56 0
 838 033c 8C2D      		mov r24,r12
 839 033e 00D0      		rcall USART_Transmit
 840               	.LVL55:
  57:main.c        ****     USART_Transmit(part);
 841               		.loc 5 57 0
 842 0340 80E5      		ldi r24,lo8(80)
 843 0342 00D0      		rcall USART_Transmit
 844               	.LVL56:
  58:main.c        ****     USART_Transmit('Y');
 845               		.loc 5 58 0
 846 0344 8D2F      		mov r24,r29
 847 0346 00D0      		rcall USART_Transmit
 848               	.LVL57:
  59:main.c        ****     USART_Transmit(cycle);
 849               		.loc 5 59 0
 850 0348 89E5      		ldi r24,lo8(89)
 851 034a 00D0      		rcall USART_Transmit
 852               	.LVL58:
  60:main.c        ****     USART_Transmit('S');
 853               		.loc 5 60 0
 854 034c 8C2F      		mov r24,r28
 855 034e 00D0      		rcall USART_Transmit
 856               	.LVL59:
  61:main.c        ****     USART_Transmit(PORTD & (1<<PD5));
 857               		.loc 5 61 0
 858 0350 83E5      		ldi r24,lo8(83)
 859 0352 00D0      		rcall USART_Transmit
 860               	.LVL60:
  62:main.c        ****     USART_putstring(":EOM:");
 861               		.loc 5 62 0
 862 0354 8BB1      		in r24,0xb
 863 0356 8072      		andi r24,lo8(32)
 864 0358 00D0      		rcall USART_Transmit
 865               	.LVL61:
  63:main.c        **** 
 866               		.loc 5 63 0
 867 035a 80E0      		ldi r24,lo8(.LC2)
 868 035c 90E0      		ldi r25,hi8(.LC2)
 869 035e 00D0      		rcall USART_putstring
 870               	.LVL62:
  65:main.c        ****       temp1 = MAX(temp1, temp2);
 871               		.loc 5 65 0
 872 0360 8C2F      		mov r24,r28
 873 0362 602F      		mov r22,r16
 874 0364 00D0      		rcall __udivmodqi4
 875 0366 9111      		cpse r25,__zero_reg__
 876 0368 00C0      		rjmp .L41
  66:main.c        ****       dt = temp1 - last_temp;
 877               		.loc 5 66 0
 878 036a 1F15      		cp r17,r15
 879 036c 00F4      		brsh .L34
 880 036e 1F2D      		mov r17,r15
 881               	.LVL63:
 882               	.L34:
  67:main.c        ****       dg = last_temp - temp1;
 883               		.loc 5 67 0
 884 0370 E12E      		mov r14,r17
 885 0372 F12C      		mov r15,__zero_reg__
 886 0374 B12C      		mov r11,__zero_reg__
 887               	.LVL64:
  68:main.c        ****       last_temp = temp1;
 888               		.loc 5 68 0
 889 0376 B501      		movw r22,r10
 890 0378 6E19      		sub r22,r14
 891 037a 7F09      		sbc r23,r15
 892 037c 8827      		clr r24
 893 037e 77FD      		sbrc r23,7
 894 0380 8095      		com r24
 895 0382 982F      		mov r25,r24
 896 0384 00D0      		rcall __floatsisf
 897               	.LVL65:
 898 0386 2B01      		movw r4,r22
 899 0388 3C01      		movw r6,r24
  67:main.c        ****       dg = last_temp - temp1;
 900               		.loc 5 67 0
 901 038a B701      		movw r22,r14
 902 038c 6A19      		sub r22,r10
 903 038e 7B09      		sbc r23,r11
 904 0390 8827      		clr r24
 905 0392 77FD      		sbrc r23,7
 906 0394 8095      		com r24
 907 0396 982F      		mov r25,r24
 908 0398 00D0      		rcall __floatsisf
 909               	.LVL66:
 910 039a 9B01      		movw r18,r22
 911 039c AC01      		movw r20,r24
  70:main.c        ****         part = part + round((30.0-part)/2.0);
 912               		.loc 5 70 0
 913 039e C301      		movw r24,r6
 914 03a0 B201      		movw r22,r4
 915 03a2 00D0      		rcall __subsf3
 916               	.LVL67:
 917 03a4 2B01      		movw r4,r22
 918 03a6 3C01      		movw r6,r24
 919 03a8 20E0      		ldi r18,0
 920 03aa 30E0      		ldi r19,0
 921 03ac A901      		movw r20,r18
 922 03ae 00D0      		rcall __gtsf2
 923               	.LVL68:
 924 03b0 1816      		cp __zero_reg__,r24
 925 03b2 04F4      		brge .L50
  71:main.c        ****       }
 926               		.loc 5 71 0
 927 03b4 6D2F      		mov r22,r29
 928 03b6 70E0      		ldi r23,0
 929 03b8 80E0      		ldi r24,0
 930 03ba 90E0      		ldi r25,0
 931 03bc 00D0      		rcall __floatsisf
 932               	.LVL69:
 933 03be 2B01      		movw r4,r22
 934 03c0 3C01      		movw r6,r24
 935 03c2 9B01      		movw r18,r22
 936 03c4 AC01      		movw r20,r24
 937 03c6 60E0      		ldi r22,0
 938 03c8 70E0      		ldi r23,0
 939 03ca 80EF      		ldi r24,lo8(-16)
 940 03cc 91E4      		ldi r25,lo8(65)
 941 03ce 00D0      		rcall __subsf3
 942               	.LVL70:
 943 03d0 20E0      		ldi r18,0
 944 03d2 30E0      		ldi r19,0
 945 03d4 40E0      		ldi r20,0
 946 03d6 5FE3      		ldi r21,lo8(63)
 947 03d8 00D0      		rcall __mulsf3
 948               	.LVL71:
 949 03da 00D0      		rcall round
 950               	.LVL72:
 951 03dc 9B01      		movw r18,r22
 952 03de AC01      		movw r20,r24
 953 03e0 C301      		movw r24,r6
 954 03e2 B201      		movw r22,r4
 955 03e4 00D0      		rcall __addsf3
 956               	.LVL73:
 957 03e6 00D0      		rcall __fixunssfsi
 958               	.LVL74:
 959 03e8 D62F      		mov r29,r22
 960               	.LVL75:
 961 03ea 00C0      		rjmp .L33
 962               	.LVL76:
 963               	.L50:
  73:main.c        ****         if (part > 0) {
 964               		.loc 5 73 0
 965 03ec 20E0      		ldi r18,0
 966 03ee 30E0      		ldi r19,0
 967 03f0 A901      		movw r20,r18
 968 03f2 C301      		movw r24,r6
 969 03f4 B201      		movw r22,r4
 970 03f6 00D0      		rcall __ltsf2
 971               	.LVL77:
 972 03f8 87FF      		sbrs r24,7
 973 03fa 00C0      		rjmp .L33
  74:main.c        ****           part = part / 2;
 974               		.loc 5 74 0
 975 03fc DD23      		tst r29
 976 03fe 01F0      		breq .L33
  75:main.c        ****         }
 977               		.loc 5 75 0
 978 0400 D695      		lsr r29
 979               	.LVL78:
 980 0402 00C0      		rjmp .L33
 981               	.LVL79:
 982               	.L41:
 983 0404 1A2D      		mov r17,r10
 984               	.LVL80:
 985               	.L33:
  80:main.c        ****       PORTD &= ~(1<<PD5);
 986               		.loc 5 80 0
 987 0406 CD13      		cpse r28,r29
 988 0408 00C0      		rjmp .L38
  81:main.c        ****     }
 989               		.loc 5 81 0
 990 040a 5D98      		cbi 0xb,5
 991               	.L38:
  83:main.c        ****       if (part > 0) {
 992               		.loc 5 83 0
 993 040c C111      		cpse r28,__zero_reg__
 994 040e 00C0      		rjmp .L39
  84:main.c        ****         PORTD |= (1<<PD5);
 995               		.loc 5 84 0
 996 0410 D111      		cpse r29,__zero_reg__
  85:main.c        ****       }
 997               		.loc 5 85 0
 998 0412 5D9A      		sbi 0xb,5
 999               	.L39:
 1000               		.loc 5 88 0
 1001 0414 8C2F      		mov r24,r28
 1002 0416 90E0      		ldi r25,0
 1003 0418 0196      		adiw r24,1
 1004 041a B401      		movw r22,r8
 1005 041c 00D0      		rcall __divmodhi4
 1006 041e C82F      		mov r28,r24
 1007               	.LVL81:
  89:main.c        **** 
  90:main.c        ****     temp1 = phys_temp(0);
 1008               		.loc 5 90 0
 1009 0420 80E0      		ldi r24,0
 1010 0422 90E0      		ldi r25,0
 1011               	.LVL82:
 1012 0424 00D0      		rcall phys_temp
 1013               	.LVL83:
  91:main.c        ****     temp2 = phys_temp(1);
 1014               		.loc 5 91 0
 1015 0426 81E0      		ldi r24,lo8(1)
 1016 0428 90E0      		ldi r25,0
 1017 042a 00D0      		rcall phys_temp
 1018               	.LVL84:
 1019               	.LBB24:
 1020               	.LBB25:
 164:/usr/avr/include/util/delay.h **** 
 1021               		.loc 3 164 0
 1022 042c 2FE1      		ldi r18,lo8(179999)
 1023 042e 8FEB      		ldi r24,hi8(179999)
 1024 0430 92E0      		ldi r25,hlo8(179999)
 1025 0432 2150      		1: subi r18,1
 1026 0434 8040      		sbci r24,0
 1027 0436 9040      		sbci r25,0
 1028 0438 01F4      		brne 1b
 1029 043a 00C0      		rjmp .
 1030 043c 0000      		nop
 1031 043e A12E      		mov r10,r17
 1032 0440 00C0      		rjmp .L32
 1033               	.LVL85:
 1034               	.L51:
 1035               	.LBE25:
 1036               	.LBE24:
  92:main.c        **** 
  93:main.c        ****     _delay_ms(900);
  94:main.c        **** 
  95:main.c        ****   }
  96:main.c        **** 
  97:main.c        ****   PORTD &= ~(1<<PD5);
 1037               		.loc 5 97 0
 1038 0442 5D98      		cbi 0xb,5
 1039               	/* epilogue start */
  98:main.c        **** }
 1040               		.loc 5 98 0
 1041 0444 DF91      		pop r29
 1042               	.LVL86:
 1043 0446 CF91      		pop r28
 1044               	.LVL87:
 1045 0448 1F91      		pop r17
 1046 044a 0F91      		pop r16
 1047 044c FF90      		pop r15
 1048 044e EF90      		pop r14
 1049 0450 DF90      		pop r13
 1050 0452 CF90      		pop r12
 1051               	.LVL88:
 1052 0454 BF90      		pop r11
 1053 0456 AF90      		pop r10
 1054               	.LVL89:
 1055 0458 9F90      		pop r9
 1056 045a 8F90      		pop r8
 1057 045c 7F90      		pop r7
 1058 045e 6F90      		pop r6
 1059 0460 5F90      		pop r5
 1060 0462 4F90      		pop r4
 1061 0464 0895      		ret
 1062               		.cfi_endproc
 1063               	.LFE15:
 1065               		.section	.rodata.str1.1
 1066               	.LC3:
 1067 0011 5265 6164 		.string	"Ready"
 1067      7900 
 1068               		.section	.text.startup,"ax",@progbits
 1069               	.global	main
 1071               	main:
 1072               	.LFB16:
  99:main.c        **** 
 100:main.c        **** 
 101:main.c        **** int main () {
 1073               		.loc 5 101 0
 1074               		.cfi_startproc
 1075               	/* prologue: function */
 1076               	/* frame size = 0 */
 1077               	/* stack size = 0 */
 1078               	.L__stack_usage = 0
 102:main.c        ****   
 103:main.c        ****   // Relay controller 1;
 104:main.c        ****   DDRD |= (1<<PD5);
 1079               		.loc 5 104 0
 1080 0000 559A      		sbi 0xa,5
 105:main.c        ****   // Relay controller 2;
 106:main.c        ****   DDRB |= (1<<PB0);
 1081               		.loc 5 106 0
 1082 0002 209A      		sbi 0x4,0
 107:main.c        ****   USART_Init();
 1083               		.loc 5 107 0
 1084 0004 00D0      		rcall USART_Init
 1085               	.LVL90:
 108:main.c        ****   ADC_init();
 1086               		.loc 5 108 0
 1087 0006 00D0      		rcall ADC_init
 1088               	.LVL91:
 109:main.c        ****   USART_putstring("Ready");
 1089               		.loc 5 109 0
 1090 0008 80E0      		ldi r24,lo8(.LC3)
 1091 000a 90E0      		ldi r25,hi8(.LC3)
 1092 000c 00D0      		rcall USART_putstring
 1093               	.LVL92:
 110:main.c        ****   sei();
 1094               		.loc 5 110 0
 1095               	/* #APP */
 1096               	 ;  110 "main.c" 1
 1097 000e 7894      		sei
 1098               	 ;  0 "" 2
 1099               	/* #NOAPP */
 1100               	.L53:
 111:main.c        ****   while (1) {
 112:main.c        ****     if (start == 1) {
 1101               		.loc 5 112 0
 1102 0010 8091 0000 		lds r24,start
 1103 0014 8130      		cpi r24,lo8(1)
 1104 0016 01F4      		brne .L53
 113:main.c        ****       run();
 1105               		.loc 5 113 0
 1106 0018 00D0      		rcall run
 1107               	.LVL93:
 114:main.c        ****       USART_putstring("Ready");
 1108               		.loc 5 114 0
 1109 001a 80E0      		ldi r24,lo8(.LC3)
 1110 001c 90E0      		ldi r25,hi8(.LC3)
 1111 001e 00D0      		rcall USART_putstring
 1112               	.LVL94:
 1113 0020 00C0      		rjmp .L53
 1114               		.cfi_endproc
 1115               	.LFE16:
 1117               		.comm	status,1,1
 1118               		.comm	start,1,1
 1119               		.comm	update,1,1
 1120               	.global	mux_mask
 1121               		.section	.rodata
 1124               	mux_mask:
 1125 0000 04        		.byte	4
 1126 0001 05        		.byte	5
 1127               	.global	log_resistors
 1130               	log_resistors:
 1131 0002 2A        		.byte	42
 1132 0003 41        		.byte	65
 1133 0004 1E        		.byte	30
 1134 0005 41        		.byte	65
 1135 0006 85        		.byte	-123
 1136 0007 4B        		.byte	75
 1137 0008 1E        		.byte	30
 1138 0009 41        		.byte	65
 1139               	.global	phys_params
 1142               	phys_params:
 1143 000a FB        		.byte	-5
 1144 000b 1A        		.byte	26
 1145 000c 6E        		.byte	110
 1146 000d 3A        		.byte	58
 1147 000e 43        		.byte	67
 1148 000f BA        		.byte	-70
 1149 0010 69        		.byte	105
 1150 0011 39        		.byte	57
 1151 0012 55        		.byte	85
 1152 0013 C3        		.byte	-61
 1153 0014 35        		.byte	53
 1154 0015 33        		.byte	51
 1155 0016 DD        		.byte	-35
 1156 0017 5B        		.byte	91
 1157 0018 91        		.byte	-111
 1158 0019 3A        		.byte	58
 1159 001a D3        		.byte	-45
 1160 001b D9        		.byte	-39
 1161 001c 49        		.byte	73
 1162 001d 39        		.byte	57
 1163 001e 8A        		.byte	-118
 1164 001f F2        		.byte	-14
 1165 0020 1D        		.byte	29
 1166 0021 34        		.byte	52
 1167               		.text
 1168               	.Letext0:
 1169               		.file 6 "/usr/avr/include/stdint.h"
 1170               		.file 7 "sensors.h"
 1171               		.file 8 "/usr/avr/include/math.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccXJ5qET.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccXJ5qET.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccXJ5qET.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccXJ5qET.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccXJ5qET.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccXJ5qET.s:12     .text:0000000000000000 USART_Init
     /tmp/ccXJ5qET.s:38     .text:0000000000000018 USART_Transmit
     /tmp/ccXJ5qET.s:60     .text:0000000000000026 USART_Flush
     /tmp/ccXJ5qET.s:85     .text:0000000000000036 USART_putstring
     /tmp/ccXJ5qET.s:127    .text:000000000000004c ADC_init
     /tmp/ccXJ5qET.s:160    .text:000000000000006c read_ts
     /tmp/ccXJ5qET.s:283    .text:00000000000000fe phys_temp
     /tmp/ccXJ5qET.s:1124   .rodata:0000000000000000 mux_mask
     /tmp/ccXJ5qET.s:1130   .rodata:0000000000000002 log_resistors
     /tmp/ccXJ5qET.s:1142   .rodata:000000000000000a phys_params
     /tmp/ccXJ5qET.s:512    .text:0000000000000224 RTC_init
     /tmp/ccXJ5qET.s:572    .text:000000000000026e __vector_18
                            *COM*:0000000000000001 start
     /tmp/ccXJ5qET.s:702    .text:00000000000002d4 run
     /tmp/ccXJ5qET.s:1071   .text.startup:0000000000000000 main
                            *COM*:0000000000000001 status
                            *COM*:0000000000000001 update

UNDEFINED SYMBOLS
__floatunsisf
__addsf3
__subsf3
__mulsf3
__divsf3
__fixsfsi
log
pow
__floatsisf
__gtsf2
__fixunssfsi
__ltsf2
__udivmodqi4
round
__divmodhi4
__do_copy_data
__do_clear_bss
